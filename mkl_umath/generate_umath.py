# Copyright (c) 2019, Intel Corporation
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of Intel Corporation nor the names of its contributors
#       may be used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Adapted with modifications from
# https://github.com/numpy/numpy/blob/maintenance/2.2.x/numpy/_core/code_generators/generate_umath.py
# Differences with the NumPy file:
# 1) The `defdict` dictionary is completely different.
# 2) In the `make_arrays` function, `cfunc_fname = f"{tname}_*"` is changed to `cfunc_fname = f"mkl_umath_{tname}_*"`
# 3) In the `make_ufuncs` function, line 988: `{doc}` is changed to `"{doc}"`
# 4) In the `make_code` function, the string used there is different.

"""
Generate the code to build all the internal ufuncs. At the base is the defdict:
a dictionary of Ufunc classes. This is fed to make_code to generate
__umath_generated.c
"""
import os
import re
import textwrap
import argparse
import numpy as np

# identity objects
Zero = "PyLong_FromLong(0)"
One = "PyLong_FromLong(1)"
True_ = "(Py_INCREF(Py_True), Py_True)"
False_ = "(Py_INCREF(Py_False), Py_False)"
None_ = object()
AllOnes = "PyLong_FromLong(-1)"
MinusInfinity = 'PyFloat_FromDouble(-NPY_INFINITY)'
ReorderableNone = "(Py_INCREF(Py_None), Py_None)"

class docstrings:
    @staticmethod
    def get(place):
        """
        Returns the C #definition name of docstring according
        to ufunc place. C #definitions are generated by generate_umath_doc.py
        in a separate C header.
        """
        return 'DOC_' + place.upper().replace('.', '_')

# Sentinel value to specify using the full type description in the
# function name
class FullTypeDescr:
    pass

class FuncNameSuffix:
    """Stores the suffix to append when generating functions names.
    """
    def __init__(self, suffix):
        self.suffix = suffix

class TypeDescription:
    """Type signature for a ufunc.

    Attributes
    ----------
    type : str
        Character representing the nominal type.
    func_data : str or None or FullTypeDescr or FuncNameSuffix, optional
        The string representing the expression to insert into the data
        array, if any.
    in_ : str or None, optional
        The typecode(s) of the inputs.
    out : str or None, optional
        The typecode(s) of the outputs.
    astype : dict or None, optional
        If astype['x'] is 'y', uses PyUFunc_x_x_As_y_y/PyUFunc_xx_x_As_yy_y
        instead of PyUFunc_x_x/PyUFunc_xx_x.
    cfunc_alias : str or none, optional
        Appended to inner loop C function name, e.g., FLOAT_{cfunc_alias}. See make_arrays.
        NOTE: it doesn't support 'astype'
    dispatch : str or None, optional
        Dispatch-able source name without its extension '.dispatch.c' that
        contains the definition of ufunc, dispatched at runtime depending on the
        specified targets of the dispatch-able source.
        NOTE: it doesn't support 'astype'
    """
    def __init__(self, type, f=None, in_=None, out=None, astype=None, cfunc_alias=None,
                 dispatch=None):
        self.type = type
        self.func_data = f
        if astype is None:
            astype = {}
        self.astype_dict = astype
        if in_ is not None:
            in_ = in_.replace('P', type)
        self.in_ = in_
        if out is not None:
            out = out.replace('P', type)
        self.out = out
        self.cfunc_alias = cfunc_alias
        self.dispatch = dispatch

    def finish_signature(self, nin, nout):
        if self.in_ is None:
            self.in_ = self.type * nin
        assert len(self.in_) == nin
        if self.out is None:
            self.out = self.type * nout
        assert len(self.out) == nout
        self.astype = self.astype_dict.get(self.type, None)


def _check_order(types1, types2):
    """
    Helper to check that the loop types are ordered. The legacy type resolver
    (and potentially downstream) may pick use the first loop to which operands
    can be cast safely.
    """
    # Insert kK (int64) after all other ints (assumes long long isn't larger)
    dtype_order = bints + 'kK' + times + flts + cmplxP + "O"
    for t1, t2 in zip(types1, types2):
        # We have no opinion on object or time ordering for now:
        if t1 in "OP" or t2 in "OP":
            return True
        if t1 in "mM" or t2 in "mM":
            return True

        t1i = dtype_order.index(t1)
        t2i = dtype_order.index(t2)
        if t1i < t2i:
            return
        if t2i > t1i:
            break

    if types1 == "QQ?" and types2 == "qQ?":
        # Explicitly allow this mixed case, rather than figure out what order
        # is nicer or how to encode it.
        return

    raise TypeError(
            f"Input dtypes are unsorted or duplicate: {types1} and {types2}")


def check_td_order(tds):
    # A quick check for whether the signatures make sense, it happened too
    # often that SIMD additions added loops that do not even make some sense.
    # TODO: This should likely be a test and it would be nice if it rejected
    #       duplicate entries as well (but we have many as of writing this).
    signatures = [t.in_+t.out for t in tds]

    for prev_i, sign in enumerate(signatures[1:]):
        if sign in signatures[:prev_i+1]:
            continue  # allow duplicates...

        _check_order(signatures[prev_i], sign)


_floatformat_map = dict(
    e='npy_%sf',
    f='npy_%sf',
    d='npy_%s',
    g='npy_%sl',
    F='nc_%sf',
    D='nc_%s',
    G='nc_%sl'
)

def build_func_data(types, f):
    func_data = [_floatformat_map.get(t, '%s') % (f,) for t in types]
    return func_data

def TD(types, f=None, astype=None, in_=None, out=None, cfunc_alias=None,
       dispatch=None):
    """
    Generate a TypeDescription instance for each item in types
    """
    if f is not None:
        if isinstance(f, str):
            func_data = build_func_data(types, f)
        elif len(f) != len(types):
            raise ValueError("Number of types and f do not match")
        else:
            func_data = f
    else:
        func_data = (None,) * len(types)
    if isinstance(in_, str):
        in_ = (in_,) * len(types)
    elif in_ is None:
        in_ = (None,) * len(types)
    elif len(in_) != len(types):
        raise ValueError("Number of types and inputs do not match")
    if isinstance(out, str):
        out = (out,) * len(types)
    elif out is None:
        out = (None,) * len(types)
    elif len(out) != len(types):
        raise ValueError("Number of types and outputs do not match")
    tds = []
    for t, fd, i, o in zip(types, func_data, in_, out):
        # [(dispatch file name without extension '.dispatch.c*', list of types)]
        if dispatch:
            dispt = ([k for k, v in dispatch if t in v]+[None])[0]
        else:
            dispt = None
        tds.append(TypeDescription(
            t, f=fd, in_=i, out=o, astype=astype, cfunc_alias=cfunc_alias,
            dispatch=dispt
        ))
    return tds

class Ufunc:
    """Description of a ufunc.

    Attributes
    ----------
    nin : number of input arguments
    nout : number of output arguments
    identity : identity element for a two-argument function (like Zero)
    docstring : docstring for the ufunc
    typereso: type resolver function of type PyUFunc_TypeResolutionFunc
    type_descriptions : TypeDescription objects
    signature: a generalized ufunc signature (like for matmul)
    indexed: add indexed loops (ufunc.at) for these type characters
    """
    def __init__(self, nin, nout, identity, docstring, typereso,
                 *type_descriptions, signature=None, indexed=''):
        self.nin = nin
        self.nout = nout
        if identity is None:
            identity = None_
        self.identity = identity
        self.docstring = docstring
        self.typereso = typereso
        self.type_descriptions = []
        self.signature = signature
        self.indexed = indexed
        for td in type_descriptions:
            self.type_descriptions.extend(td)
        for td in self.type_descriptions:
            td.finish_signature(self.nin, self.nout)

        check_td_order(self.type_descriptions)


# String-handling utilities to avoid locale-dependence.

import string
UPPER_TABLE = bytes.maketrans(bytes(string.ascii_lowercase, "ascii"),
                              bytes(string.ascii_uppercase, "ascii"))

def english_upper(s):
    """ Apply English case rules to convert ASCII strings to all upper case.

    This is an internal utility function to replace calls to str.upper() such
    that we can avoid changing behavior with changing locales. In particular,
    Turkish has distinct dotted and dotless variants of the Latin letter "I" in
    both lowercase and uppercase. Thus, "i".upper() != "I" in a "tr" locale.

    Parameters
    ----------
    s : str

    Returns
    -------
    uppered : str

    Examples
    --------
    >>> import numpy as np
    >>> from numpy.lib.utils import english_upper
    >>> s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_'
    >>> english_upper(s)
    'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'
    >>> english_upper('')
    ''
    """
    uppered = s.translate(UPPER_TABLE)
    return uppered


#each entry in defdict is a Ufunc object.

#name: [string of chars for which it is defined,
#       string of characters using func interface,
#       tuple of strings giving funcs for data,
#       (in, out), or (instr, outstr) giving the signature as character codes,
#       identity,
#       docstring,
#       output specification (optional)
#       ]

chartoname = {
    '?': 'bool',
    'b': 'byte',
    'B': 'ubyte',
    'h': 'short',
    'H': 'ushort',
    'i': 'int',
    'I': 'uint',
    'l': 'long',
    'L': 'ulong',
    # We sometimes need int64, but we have no obvious char for it, use k and
    # define it as `int64` below.
    'k': 'int64',
    'K': 'uint64',
    'q': 'longlong',
    'Q': 'ulonglong',
    'e': 'half',
    'f': 'float',
    'd': 'double',
    'g': 'longdouble',
    'F': 'cfloat',
    'D': 'cdouble',
    'G': 'clongdouble',
    'M': 'datetime',
    'm': 'timedelta',
    'O': 'OBJECT',
    # '.' is like 'O', but calls a method of the object instead
    # of a function
    'P': 'OBJECT',
}

no_obj_bool = 'bBhHiIlLqQefdgFDGmM'
noobj = '?' + no_obj_bool
all = '?bBhHiIlLqQefdgFDGOmM'

O = 'O'
P = 'P'
ints = 'bBhHiIlLqQ'
sints = 'bhilq'
uints = 'BHILQ'
times = 'Mm'
timedeltaonly = 'm'
intsO = ints + O
bints = '?' + ints
bintsO = bints + O
flts = 'efdg'
fltsO = flts + O
fltsP = flts + P
cmplx = 'FDG'
cmplxvec = 'FD'
cmplxO = cmplx + O
cmplxP = cmplx + P
inexact = flts + cmplx
inexactvec = 'fd'
noint = inexact+O
nointP = inexact+P
allP = bints+times+flts+cmplxP
nobool_or_obj = noobj[1:]
nobool_or_datetime = noobj[1:-1] + O # includes m - timedelta64
intflt = ints+flts
intfltcmplx = ints+flts+cmplx
nocmplx = bints+times+flts
nocmplxO = nocmplx+O
nocmplxP = nocmplx+P
notimes_or_obj = bints + inexact
nodatetime_or_obj = bints + inexact
no_bool_times_obj = ints + inexact

# Find which code corresponds to int64.
int64 = 'k'
uint64 = 'K'

# This dictionary describes all the ufunc implementations, generating
# all the function names and their corresponding ufunc signatures.  TD is
# an object which expands a list of character codes into an array of
# TypeDescriptions.

if np.lib.NumpyVersion(np.__version__) < "2.0.0":
    ldexp_signature = [
        TypeDescription('f', None, 'fi', 'f'),
        TypeDescription('f', FuncNameSuffix('long'), 'fl', 'f'),
        TypeDescription('d', None, 'di', 'd'),
        TypeDescription('d', FuncNameSuffix('long'), 'dl', 'd'),
    ]
else:
    ldexp_signature = [
        TypeDescription('f', None, 'fi', 'f'),
        TypeDescription('f', FuncNameSuffix('int64'), 'f'+int64, 'f'),
        TypeDescription('d', None, 'di', 'd'),
        TypeDescription('d', FuncNameSuffix('int64'), 'd'+int64, 'd'),
    ]

defdict = {
'add':
    Ufunc(2, 1, Zero,
          docstrings.get('numpy._core.umath.add'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'subtract':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.subtract'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'multiply':
    Ufunc(2, 1, One,
          docstrings.get('numpy._core.umath.multiply'),
          None, 
          TD(inexactvec + cmplxvec),
          ),
# 'true_divide': aliased to divide
# 'floor_divide':
'divide':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.divide'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'conjugate':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.conjugate'),
          None,
          TD(inexactvec + cmplxvec),
          ),
# 'fmod':
'square':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.square'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'reciprocal':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.reciprocal'),
          None,
          TD(inexactvec + cmplxvec),
          ),
# '_ones_like':
# 'power':
# 'float_power':
'absolute':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.absolute'),
          None,
          TD(inexactvec),
          TD('F', out='f'),
          TD('D', out='d'),
          ),
# '_arg':
'negative':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.negative'),
          None,
          TD(inexactvec),
          ),
'positive':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.positive'),
          None,
          TD(inexactvec),
          ),
'sign':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sign'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'greater':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.greater'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'greater_equal':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.greater_equal'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'less':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.less'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'less_equal':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.less_equal'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'equal':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.equal'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'not_equal':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.not_equal'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'logical_and':
    Ufunc(2, 1, True_,
          docstrings.get('numpy._core.umath.logical_and'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'logical_not':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.logical_not'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'logical_or':
    Ufunc(2, 1, False_,
          docstrings.get('numpy._core.umath.logical_or'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'logical_xor':
    Ufunc(2, 1, False_,
          docstrings.get('numpy._core.umath.logical_xor'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'maximum':
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.maximum'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'minimum':
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.minimum'),
          None,
          TD(inexactvec + cmplxvec),
          ),
# 'clip':
'fmax':
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.fmax'),
          None,
          TD(inexactvec + cmplxvec),
          ),
'fmin':
    Ufunc(2, 1, ReorderableNone,
          docstrings.get('numpy._core.umath.fmin'),
          None,
          TD(inexactvec + cmplxvec),
          ),
# 'logaddexp':
# 'logaddexp2':
# 'bitwise_and':
# 'bitwise_or':
# 'bitwise_xor':
# 'invert':
# 'left_shift':
# 'right_shift':
# 'heaviside':
# 'degrees':
# 'rad2deg':
# 'radians':
# 'deg2rad':
'arccos':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arccos'),
          None,
          TD(inexactvec),
          ),
'arccosh':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arccosh'),
          None,
          TD(inexactvec),
          ),
'arcsin':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arcsin'),
          None,
          TD(inexactvec),
          ),
'arcsinh':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arcsinh'),
          None,
          TD(inexactvec),
          ),
'arctan':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arctan'),
          None,
          TD(inexactvec),
          ),
'arctanh':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.arctanh'),
          None,
          TD(inexactvec),
          ),
'cos':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.cos'),
          None,
          TD(inexactvec),
          ),
'sin':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sin'),
          None,
          TD(inexactvec),
          ),
'tan':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.tan'),
          None,
          TD(inexactvec),
          ),
'cosh':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.cosh'),
          None,
          TD(inexactvec),
          ),
'sinh':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sinh'),
          None,
          TD(inexactvec),
          ),
'tanh':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.tanh'),
          None,
          TD(inexactvec),
          ),
'exp':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.exp'),
          None,
          TD(inexactvec),
          ),
'exp2':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.exp2'),
          None,
          TD(inexactvec),
          ),
'expm1':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.expm1'),
          None,
          TD(inexactvec),
          ),
'log':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log'),
          None,
          TD(inexactvec),
          ),
'log2':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log2'),
          None,
          TD(inexactvec),
          ),
'log10':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log10'),
          None,
          TD(inexactvec),
          ),
'log1p':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.log1p'),
          None,
          TD(inexactvec),
          ),
'sqrt':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.sqrt'),
          None,
          TD(inexactvec),
          ),
'cbrt':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.cbrt'),
          None,
          TD(inexactvec),
          ),
'ceil':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.ceil'),
          None,
          TD(inexactvec),
          ),
'trunc':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.trunc'),
          None,
          TD(inexactvec),
          ),
'fabs':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.fabs'),
          None,
          TD(inexactvec),
       ),
'floor':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.floor'),
          None,
          TD(inexactvec),
          ),
'rint':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.rint'),
          None,
          TD(inexactvec),
          ),
# 'arctan2':
'remainder':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.remainder'),
          None,
          TD(inexactvec),
          ),
# 'divmod':
# 'hypot':
'isnan':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.isnan'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
# 'isnat':
'isinf':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.isinf'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
'isfinite':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.isfinite'),
          None,
          TD(inexactvec + cmplxvec, out='?'),
          ),
# 'signbit':
'copysign':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.copysign'),
          None,
          TD(inexactvec),
          ),
'nextafter':
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.nextafter'),
          None,
          TD(inexactvec),
          ),
'spacing':
    Ufunc(1, 1, None,
          docstrings.get('numpy._core.umath.spacing'),
          None,
          TD(inexactvec),
          ),
'modf':
    Ufunc(1, 2, None,
          docstrings.get('numpy._core.umath.modf'),
          None,
          TD(inexactvec),
          ),
'ldexp' :
    Ufunc(2, 1, None,
          docstrings.get('numpy._core.umath.ldexp'),
          None,
          ldexp_signature,
          ),
'frexp' :
    Ufunc(1, 2, None,
          docstrings.get('numpy._core.umath.frexp'),
          None,
          [
              TypeDescription('f', None, 'f', 'fi'),
              TypeDescription('d', None, 'd', 'di'),
          ],
          ),
# 'gcd':
# 'lcm':
# 'bitwise_count':
# 'matmul':
# 'vecdot':
# 'matvec':
# 'vecmat':
# 'str_len':
# 'isalpha':
# 'isdigit':
# 'isspace':
# 'isalnum':
# 'islower':
# 'isupper':
# 'istitle':
# 'isdecimal':
# 'isnumeric':
# 'find':
# 'rfind':
# 'count':
# 'index':
# 'rindex':
# '_replace':
# 'startswith':
# 'endswith':
# '_strip_chars':
# '_lstrip_chars':
# '_rstrip_chars':
# '_strip_whitespace':
# '_lstrip_whitespace':
# '_rstrip_whitespace':,
# '_expandtabs_length':
# '_expandtabs':
# '_center':
# '_ljust':
# '_rjust':
# '_zfill':
# '_partition_index':
# '_rpartition_index':
# '_partition':
# '_rpartition':
# '_slice':
}

def indent(st, spaces):
    indentation = ' '*spaces
    indented = indentation + st.replace('\n', '\n'+indentation)
    # trim off any trailing spaces
    indented = re.sub(r' +$', r'', indented)
    return indented

# maps [nin, nout][type] to a suffix
arity_lookup = {
    (1, 1): {
        'e': 'e_e',
        'f': 'f_f',
        'd': 'd_d',
        'g': 'g_g',
        'F': 'F_F',
        'D': 'D_D',
        'G': 'G_G',
        'O': 'O_O',
        'P': 'O_O_method',
    },
    (2, 1): {
        'e': 'ee_e',
        'f': 'ff_f',
        'd': 'dd_d',
        'g': 'gg_g',
        'F': 'FF_F',
        'D': 'DD_D',
        'G': 'GG_G',
        'O': 'OO_O',
        'P': 'OO_O_method',
    },
    (3, 1): {
        'O': 'OOO_O',
    }
}

#for each name
# 1) create functions, data, and signature
# 2) fill in functions and data in InitOperators
# 3) add function.

def make_arrays(funcdict):
    # functions array contains an entry for every type implemented NULL
    # should be placed where PyUfunc_ style function will be filled in
    # later
    code1list = []
    code2list = []
    dispdict  = {}
    names = sorted(funcdict.keys())
    for name in names:
        uf = funcdict[name]
        funclist = []
        datalist = []
        siglist = []
        sub = 0

        for k, t in enumerate(uf.type_descriptions):
            cfunc_alias = t.cfunc_alias if t.cfunc_alias else name
            cfunc_fname = None
            if t.func_data is FullTypeDescr:
                tname = english_upper(chartoname[t.type])
                datalist.append('(void *)NULL')
                if t.out == "?":
                    cfunc_fname = f"mkl_umath_{tname}_{t.in_}_bool_{cfunc_alias}"
                else:
                    cfunc_fname = f"mkl_umath_{tname}_{t.in_}_{t.out}_{cfunc_alias}"
            elif isinstance(t.func_data, FuncNameSuffix):
                datalist.append('(void *)NULL')
                tname = english_upper(chartoname[t.type])
                cfunc_fname = f"mkl_umath_{tname}_{cfunc_alias}_{t.func_data.suffix}"
            elif t.func_data is None:
                datalist.append('(void *)NULL')
                tname = english_upper(chartoname[t.type])
                cfunc_fname = f"mkl_umath_{tname}_{cfunc_alias}"
            else:
                try:
                    thedict = arity_lookup[uf.nin, uf.nout]
                except KeyError as e:
                    raise ValueError(
                        f"Could not handle {name}[{t.type}] "
                        f"with nin={uf.nin}, nout={uf.nout}"
                    ) from None

                astype = ''
                if t.astype is not None:
                    astype = '_As_%s' % thedict[t.astype]
                astr = ('%s_functions[%d] = PyUFunc_%s%s;' %
                           (name, k, thedict[t.type], astype))
                code2list.append(astr)
                if t.type == 'O':
                    astr = ('%s_data[%d] = (void *) %s;' %
                               (name, k, t.func_data))
                    code2list.append(astr)
                    datalist.append('(void *)NULL')
                elif t.type == 'P':
                    datalist.append('(void *)"%s"' % t.func_data)
                else:
                    astr = ('%s_data[%d] = (void *) %s;' %
                               (name, k, t.func_data))
                    code2list.append(astr)
                    datalist.append('(void *)NULL')
                    #datalist.append('(void *)%s' % t.func_data)
                sub += 1

            if cfunc_fname:
                funclist.append(cfunc_fname)
                if t.dispatch:
                    dispdict.setdefault(t.dispatch, []).append(
                        (name, k, cfunc_fname, t.in_ + t.out)
                    )
            else:
                funclist.append('NULL')

            for x in t.in_ + t.out:
                siglist.append('NPY_%s' % (english_upper(chartoname[x]),))

        if funclist or siglist or datalist:
            funcnames = ', '.join(funclist)
            signames = ', '.join(siglist)
            datanames = ', '.join(datalist)
            code1list.append(
                "static PyUFuncGenericFunction %s_functions[] = {%s};"
                % (name, funcnames))
            code1list.append("static void * %s_data[] = {%s};"
                            % (name, datanames))
            code1list.append("static const char %s_signatures[] = {%s};"
                            % (name, signames))
            uf.empty = False
        else:
            uf.empty = True

    for dname, funcs in dispdict.items():
        code2list.append(textwrap.dedent(f"""
            #ifndef NPY_DISABLE_OPTIMIZATION
            #include "{dname}.dispatch.h"
            #endif
        """))
        for (ufunc_name, func_idx, cfunc_name, inout) in funcs:
            code2list.append(textwrap.dedent(f"""\
                NPY_CPU_DISPATCH_TRACE("{ufunc_name}", "{''.join(inout)}");
                NPY_CPU_DISPATCH_CALL_XB({ufunc_name}_functions[{func_idx}] = {cfunc_name});
            """))
    return "\n".join(code1list), "\n".join(code2list)

def make_ufuncs(funcdict):
    code3list = []
    names = sorted(funcdict.keys())
    for name in names:
        uf = funcdict[name]
        mlist = []
        if uf.signature is None:
            sig = "NULL"
        else:
            sig = '"{}"'.format(uf.signature)
        fmt = textwrap.dedent("""\
            identity = {identity_expr};
            if ({has_identity} && identity == NULL) {{
                return -1;
            }}
            f = PyUFunc_FromFuncAndDataAndSignatureAndIdentity(
                {funcs}, {data}, {signatures}, {nloops},
                {nin}, {nout}, {identity}, "{name}",
                "{doc}", 0, {sig}, identity
            );
            if ({has_identity}) {{
                Py_DECREF(identity);
            }}
            if (f == NULL) {{
                return -1;
            }}
        """)
        args = dict(
            name=name,
            funcs=f"{name}_functions" if not uf.empty else "NULL",
            data=f"{name}_data" if not uf.empty else "NULL",
            signatures=f"{name}_signatures" if not uf.empty else "NULL",
            nloops=len(uf.type_descriptions),
            nin=uf.nin, nout=uf.nout,
            has_identity='0' if uf.identity is None_ else '1',
            identity='PyUFunc_IdentityValue',
            identity_expr=uf.identity,
            doc=uf.docstring,
            sig=sig,
        )

        # Only PyUFunc_None means don't reorder - we pass this using the old
        # argument
        if uf.identity is None_:
            args['identity'] = 'PyUFunc_None'
            args['identity_expr'] = 'NULL'

        mlist.append(fmt.format(**args))
        if uf.typereso is not None:
            mlist.append(
                r"((PyUFuncObject *)f)->type_resolver = &%s;" % uf.typereso)
        for c in uf.indexed:
            # Handle indexed loops by getting the underlying ArrayMethodObject
            # from the list in f._loops and setting its field appropriately
            fmt = textwrap.dedent("""
            {{
                PyArray_DTypeMeta *dtype = PyArray_DTypeFromTypeNum({typenum});
                PyObject *info = get_info_no_cast((PyUFuncObject *)f,
                                                   dtype, {count});
                if (info == NULL) {{
                    return -1;
                }}
                if (info == Py_None) {{
                    PyErr_SetString(PyExc_RuntimeError,
                        "cannot add indexed loop to ufunc "
                        "{name} with {typenum}");
                    return -1;
                }}
                if (!PyObject_TypeCheck(info, &PyArrayMethod_Type)) {{
                    PyErr_SetString(PyExc_RuntimeError,
                        "Not a PyArrayMethodObject in ufunc "
                        "{name} with {typenum}");
                }}
                ((PyArrayMethodObject*)info)->contiguous_indexed_loop =
                                                                 {funcname};
                /* info is borrowed, no need to decref*/
            }}
            """)
            mlist.append(fmt.format(
                typenum=f"NPY_{english_upper(chartoname[c])}",
                count=uf.nin+uf.nout,
                name=name,
                funcname = f"{english_upper(chartoname[c])}_{name}_indexed",
            ))

        mlist.append(r"""PyDict_SetItemString(dictionary, "%s", f);""" % name)
        mlist.append(r"""Py_DECREF(f);""")
        code3list.append('\n'.join(mlist))
    return '\n'.join(code3list)

def make_code(funcdict, filename):
    code1, code2 = make_arrays(funcdict)
    code3 = make_ufuncs(funcdict)
    code2 = indent(code2, 4)
    code3 = indent(code3, 4)
    code = textwrap.dedent(r"""

    /** Warning this file is autogenerated!!!

        Please make changes to the code generator program (%s)
    **/
    #include "Python.h"
    #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
    #include "numpy/arrayobject.h"
    #include "numpy/ufuncobject.h"
    #include "mkl_umath_loops.h"
    %s

    static int
    InitOperators(PyObject *dictionary) {
        PyObject *f, *identity;

    %s
    %s

        return 0;
    }
    """) % (os.path.basename(filename), code1, code2, code3)
    return code


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-o",
        "--outfile",
        type=str,
        help="Path to the output directory"
    )
    args = parser.parse_args()

    # used to insert the name of this file into the generated file
    filename = __file__
    code = make_code(defdict, filename)

    if not args.outfile:
        # This is the distutils-based build
        outfile = '__umath_generated.c'
    else:
        outfile = os.path.join(os.getcwd(), args.outfile)

    with open(outfile, 'w') as f:
        f.write(code)


if __name__ == "__main__":
    main()
